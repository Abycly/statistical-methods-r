---
output: html_document
---


L'objectif de ce projet est double : premièrement, il vise à estimer la valeur en risque (VaR) d'un portefeuille composé de deux indices majeurs, le SP500 et le FTSE. La VaR est une mesure statistique utilisée pour évaluer le risque de perte sur un portefeuille d'investissements. Pour ce faire, nous utiliserons le modèle GARCH(1,1)-Normal, un outil économétrique réputé pour sa capacité à capturer l'hétéroscédasticité des séries temporelles financières. Le modèle GARCH, avec ses paramètres ajustables, permet de modéliser la volatilité conditionnelle et de prévoir ainsi la volatilité future, un élément crucial pour la gestion du risque.

Deuxièmement, nous procéderons au backtesting de la VaR calculée, une étape cruciale qui permet de vérifier l'efficacité de la mesure de risque estimée par notre modèle en la confrontant aux pertes réelles observées. Pour mener à bien ce projet, il sera nécessaire de compléter et de corriger les codes fournis qui ne fonctionnent pas en l'état actuel.

## Etape Données :

Chargeons le fichier 'indices.rda' dans R. Nous considerons que les valeurs des indices depuis janvier 2005. Ensuite, calculons les rendements logarithmiques pour les deux séries.

```{r}
library("qrmdata")
library("PerformanceAnalytics")
library("here")

# Chargement du fichier .rda
data <- load(here("MATH 60633 tp01", "indices.rda"))

price <- prices["2005-01/2013-07"] #Sélection de notre période

#Calcul pour les rendements logarithm
price$log_returns_SP500 <- PerformanceAnalytics::CalculateReturns(price$SP500, method= "log"
)

price$log_returns_FTSE100 <- PerformanceAnalytics::CalculateReturns(price$FTSE100, method= "log"
)

```

```{r}
price_SP500 <-price$log_returns_SP500[-1,]

price_FTSE100 <-price$log_returns_FTSE100[-1,]

```

```{r}
#création d'un dataframe 
#(j'ai préféré le dataframe au lieu d'une matrice pour la memoire  car j'utiliserai lapply dnans la suite de mon code qui fonctionne qu'avec lapply)
price_data <- data.frame(SP500 = price_SP500,FTSE100 = price_FTSE100)
```

## Etape Fonctions

Corrigeons la fonction R f_forecast_var.R qui calcule la prévision de la VaR next-step-ahead en utilisant le modèle GARCH avec des erreurs normales.

Dans la fonction f_forecast_var, il s'agit de completer déja:

\* *LB* qui est la borne low pour les contraintes sur les paramètres qui sont positifs ( on a préferé utilisé $e^{-7}$ qui est légèrement supérieure à 0 pour maintenir la stabilité numérique pendant le processus d'optimisation) et doit vérifier une condition de covariance stationary. Ainsi,on a:

-   **les contraintes de stabilité A et b**.

$\alpha_0 \geq 0$ (le terme constant doit être positif ou nul)

$\alpha_1 \geq 0$ (le coefficient de rendement retardé carré doit être positif ou nul) $\beta_1 \geq 0$ (le coefficient de variance conditionnelle retardée doit être positif ou nul)

$-\alpha_1 - \beta_1 \geq -1$ (ce qui équivaut à $\alpha_1 + \beta_1 \leq 1e^{-7}$)

-   Pour l'optimisation, nous utilisons constOptim qui est mieux spécialisé dans l'optimisation sous contraintes linéaires au lieu de Optim.

```{r}
f_forecast_var <- function(y, level) {
  ### Compute the VaR forecast of a GARCH(1,1) model with Normal errors at the desired risk level
  #  INPUTS
  #   y     : [vector] (T x 1) of observations (log-returns)
  #   level : [scalar] risk level (e.g. 0.95 for a VaR at the 95# risk level)
  #  OUTPUTS
  #   VaR   : [scalar] VaR forecast 
  #   sig2  : [vector] (T+1 x 1) conditional variances
  #   theta : [vector] GARCH parameters
  #  NOTE
  #   o the estimation is done by maximum likelihood
  
  # Fit a GARCH(1,1) model with Normal errors
  # Starting values and bounds
  theta0 <- c(0.1 * var(y), 0.1, 0.8)
  LB     <- c(1e-7,1e-7,1e-7) 
  # avec c(0,0,0) on aura les memes résultats, c'est juste pour éviter de rencontres des erreurs.    
  
  # Stationarity condition
  A <- matrix(c(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -1, -1), nrow = 4,ncol = 3, byrow = TRUE)
  b <- -1 
  
  # Run the optimization using OPTIM
   
  
  optim_resultat <-  constrOptim(theta = theta0, 
                                 f = f_nll, 
                                 grad = NULL, 
                                 ui=A, 
                                 ci = matrix(c(LB,b),
                                             nrow=4,
                                             ncol=1,
                                             byrow = TRUE), 
                                 y = y)
  
 
 theta <-optim_resultat$par
  # Recompute the conditional variance
  sig2 <-f_ht(theta,y)   # la fonction f_ht permet de calculer les conditional variance
  
  
  # Compute the next-day ahead VaR for the Normal model
  VaR <- - qnorm(level)*sqrt(sig2[length(sig2)])   #gràce à la définition de var.
  
  out <- list(VaR_Forecast = VaR, 
              ConditionalVariances = sig2, 
              GARCH_param = theta)
  
  out
}
```

## Rappel

La log-vraisemblance d'une loi normale pour un échantillon $y_1, y_2, ..., y_n$ provenant d'une distribution normale avec une moyenne $\mu$ et un écart-type $\sigma$ est donnée par :

$$
 -\frac{n}{2} \log(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{i=1}^{n} (y_i - \mu)^2
$$

où $\log$ représente le logarithme naturel, $\pi$ est la constante pi, $\sigma^2$ est la variance, $n$ est le nombre d'observations et $y_i$ sont les observations. L'objectif est de maximiser cette fonction pour estimer les paramètres $\mu$ et $\sigma$ de la distribution normale. Avec les models de Garch(1,1), nous avons $\mu$ = 0. DDonc on a:

$$
 -\frac{n}{2} \log(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{i=1}^{n} (y_i)^2
$$

```{r}
f_nll <- function(theta, y) {
  ### Fonction which computes the negative log likelihood value 
  ### of a GARCH model with Normal errors
  #  INPUTS
  #   theta  : [vector] of parameters
  #   y      : [vector] (T x 1) of observations
  #  OUTPUTS
  #   nll    : [scalar] negative log likelihood value
  
  T <- length(y)
  
  # Compute the conditional variance of a GARCH(1,1) model
  sig2 <- f_ht(theta,y)   
  
  # Consider the T values
  sig2 <- sig2[1:T]
  
  # Compute the loglikelihood
  ll <- sum(dnorm(x=y,mean = 0,sd=sqrt(sig2),log=T)) 
  #0.5 * sum(log(2 * pi * sig2) + (y^2) / sig2)
  # j'ai préféré utiliser la fonction de R qui existe déjà. L'autre méthode avec la formule analytique génère des erreurs :) :) 
        
  
  # Output the negative value
  nll <- -ll
  
  nll
}

```

```{r}
f_ht <- function(theta, y)  {
  ### Function which computes the vector of conditional variance
  #  INPUTS
  #   x0 : [vector] (3 x 1)
  #   y     : [vector] (T x 1) log-returns
  #  OUTPUTS 
  #   sig2  : [vector] (T+1 x 1) conditional variances
  
  # Extract the parameters
  a0 <- theta[1]
  a1 <- theta[2]
  b1 <- theta[3]
  
  T <- length(y)
  
  # Initialize the conditional variances
  sig2 <- rep(NA, T + 1)
  
  # Start with unconditional variances
  sig2[1] <- a0 / (1 - a1 - b1)
  
  # Compute conditional variance at each step
  # σt^2 = ω + αyt−1^2 + βσ^2t
  
  
  for (t in 2:(T + 1)) {
    sig2[t] <- a0 + a1 * (y[t-1])^2 + b1 * sig2[t-1]
  }
  
  sig2
}

```

## Estimation statique de la Var

Utilisons les premiers rendements logarithmiques de T = 1000 pour estimer la VaR de chaque indice au niveau de risque de 95%.

```{r}
T<- 1000

results <- lapply(price_data, function(index_return) {
  f_forecast_var(y = index_return[1:T], level = 0.95)
})

var <- sapply(results, function(result) {
  result$VaR_Forecast
})

plus_risque <- which.max(abs(var))

print(paste("L'indice le plus risqué à T+1 est ",plus_risque))
var

```

On a : L'indice le plus risqué à T+1 avec nos données est *1* qui correspond à SP500 avec le var le plus grand .

Comme var, nous avons :

SP500 FTSE100

log_returns_SP500 log_returns_FTSE100

-0.06942495 -0.06236880

Ainsi, selon les estimations de VaR calculées à partir des données historiques, le SP500 est perçu comme ayant un potentiel de perte plus élevé que le FTSE100 à l'horizon T+1, c'est-à-dire le jour suivant la période de temps considérée pour l'estimation.

```         
```

## Backtesting

En utilisant une fenêtre glissante de T = 1000 jours, calculons et stockons la VaR de la prochaine étape à venir au niveau de risque de 95% pour les 1000 prochains jours.

```{r}
T <- 1000
n <- nrow(price_data) - 1

vaR_forecasts_SP500 <- numeric(n - T)
vaR_forecasts_FTSE100 <- numeric(n - T)

for (i in (T+1):n) {
  vaR_forecasts_SP500 [i - T]<- f_forecast_var(y =        price_data$log_returns_SP500[(i-T):(i-1)],level = 0.95)$VaR_Forecast

  
  vaR_forecasts_FTSE100[i - T] <- f_forecast_var(y = price_data$log_returns_FTSE100[(i-T):(i-1)], level = 0.95)$VaR_Forecast
  
}
```

Affichons les séries de rendements réalisés et les estimations de la VaR pour les deux séries. Enregistrez dans un fichier png

Pour SP500,on a:

```{r}
png("SP500_VaR.png")
n<- length(price_SP500)

plot(index(price_SP500[(T+1):(n-1)]),
     as.numeric(price_SP500[(T+1):(n-1)]),
     type = 'l',
     main = "S&P 500 Log Returns  et VaR",
     ylab = "Log Returns")

lines(index(price_SP500[(T+1):(n-1)]),
      vaR_forecasts_SP500,col ="red",lwd = 2)

dev.off()
```

![](images/Capture%20d'écran%202024-03-01%20154600.png)


Pour FTSE100, on a:

```{r}
png("FTSE100_VaR.png")
n <- length(price_FTSE100)
plot(index(price_FTSE100[(T+1):(n-1)]),
     as.numeric(price_SP500[(T+1):(n-1)]),
     type = 'l',
     main = "FTSE 100 Log Returns et VaR",
     ylab = "Log Returns")

lines(index(price_FTSE100[(T+1):(n-1)]), 
      vaR_forecasts_FTSE100, 
      col = "green", lwd =2)

dev.off()
```

![](images/Capture%20d'écran%202024-03-01%20220710.png)


```{r}
save(vaR_forecasts_SP500, vaR_forecasts_FTSE100, file = "backtest_results.rda")

```
